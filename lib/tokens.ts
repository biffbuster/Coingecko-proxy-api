// Token data from CSV - embedded for Edge Runtime compatibility
export const tokenList = [
  { name: 'Aptos', ticker: 'APT', startDate: 'March 21, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'Berachain', ticker: 'BERA', startDate: 'December 2024', hasToken: true, category: 'L0/L1' },
  { name: 'Injective', ticker: 'INJ', startDate: 'June 3, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'Kaia', ticker: 'KAIA', startDate: 'April 8, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'MANTRA', ticker: 'OM', startDate: 'April 8, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'Movement', ticker: 'MOVE', startDate: 'January 6, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'Near', ticker: 'NEAR', startDate: 'May 27, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'PEAQ', ticker: 'PEAQ', startDate: 'June 18, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'Polkadot', ticker: 'DOT', startDate: 'February 13, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'Sei', ticker: 'SEI', startDate: 'January 8, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'Sonic', ticker: 'S', startDate: 'June 27, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'Story', ticker: 'STORY', startDate: 'January 7, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'XION', ticker: 'XION', startDate: 'November 28, 2025', hasToken: true, category: 'L0/L1' },
  { name: 'CreatorBid', ticker: 'BID', startDate: 'June 13, 2025', hasToken: true, category: 'AI Agents' },
  { name: 'Newton', ticker: 'NEWT', startDate: 'May 17, 2025', hasToken: true, category: 'AI Agents' },
  { name: 'Virtuals Protocol', ticker: 'VIRTUAL', startDate: 'May 13, 2025', hasToken: true, category: 'AI Agents' },
  { name: 'Warden Protocol', ticker: 'WARD', startDate: 'June 18, 2025', hasToken: true, category: 'AI Agents' },
  { name: 'Wayfinder', ticker: 'PROMPT', startDate: 'April 4, 2025', hasToken: true, category: 'AI Agents' },
  { name: 'ANIME', ticker: 'ANIME', startDate: 'January 9, 2025', hasToken: true, category: 'Culture' },
  { name: 'Boop', ticker: 'BOOP', startDate: 'May 1, 2025', hasToken: true, category: 'Culture' },
  { name: 'PENGU', ticker: 'PENGU', startDate: 'May 5, 2025', hasToken: true, category: 'Culture' },
  { name: 'Corn', ticker: 'CORN', startDate: 'December 2024', hasToken: true, category: 'BTCFi' },
  { name: 'GOAT Network', ticker: 'GOATED', startDate: 'June 17, 2025', hasToken: true, category: 'BTCFi' },
  { name: 'Arbitrum', ticker: 'ARB', startDate: 'May 27, 2025', hasToken: true, category: 'L2' },
  { name: 'Katana', ticker: 'KAT', startDate: 'June 10, 2025', hasToken: true, category: 'L2' },
  { name: 'Mantle', ticker: 'MNT', startDate: 'May 18, 2025', hasToken: true, category: 'L2' },
  { name: 'Polygon', ticker: 'MATIC', startDate: 'July 29, 2025', hasToken: true, category: 'L2' },
  { name: 'SOON', ticker: 'SOON', startDate: 'May 12, 2025', hasToken: true, category: 'L2' },
  { name: 'Falcon Finance', ticker: 'FF', startDate: 'August 5, 2025', hasToken: true, category: 'DeFi' },
  { name: 'Frax', ticker: 'FRAX', startDate: 'Early 2025', hasToken: true, category: 'DeFi' },
  { name: 'Huma', ticker: 'HUMA', startDate: 'May 19, 2025', hasToken: true, category: 'DeFi' },
  { name: 'Orderly', ticker: 'ORDER', startDate: 'June 24, 2025', hasToken: true, category: 'DeFi' },
  { name: 'Pyth', ticker: 'PYTH', startDate: 'March 11, 2025', hasToken: true, category: 'DeFi' },
  { name: 'Starknet', ticker: 'STRK', startDate: 'Early 2025', hasToken: true, category: 'ZK' },
  { name: 'Zcash', ticker: 'ZEC', startDate: 'June 6, 2025', hasToken: true, category: 'ZK' },
  { name: 'Humanity Protocol', ticker: 'H', startDate: 'May 28, 2025', hasToken: true, category: 'Others' },
  { name: 'dYdX', ticker: 'DYDX', startDate: 'May 14, 2025', hasToken: true, category: 'Exchange' },
  { name: 'Kaito', ticker: 'KAITO', startDate: 'December 2024', hasToken: true, category: 'AI' },
  { name: 'IQ', ticker: 'IQ', startDate: 'April 9, 2025', hasToken: true, category: 'AI' },
  { name: 'UXLINK', ticker: 'UXLINK', startDate: 'June 12, 2025', hasToken: true, category: 'AI' },
  { name: 'Defi App', ticker: 'DEFI', startDate: 'March 4, 2025', hasToken: true, category: 'Consumer' },
  { name: 'MapleStory Universe', ticker: 'NXPC', startDate: 'May 13, 2025', hasToken: true, category: 'Consumer' },
  { name: 'Sophon', ticker: 'SOPH', startDate: 'March 31, 2025', hasToken: true, category: 'Consumer' },
  { name: 'Initia', ticker: 'INIT', startDate: 'March 27, 2025', hasToken: true, category: 'Interop' },
  { name: 'Skate', ticker: 'SKATE', startDate: 'February 25, 2025', hasToken: true, category: 'Interop' },
];

export function getCoinIdFromTicker(ticker: string): string {
  const tickerMap: Record<string, string> = {
    'APT': 'aptos',
    'BERA': 'berachain',
    'INJ': 'injective-protocol',
    'KAIA': 'kaia',
    'OM': 'mantra-dao',
    'MOVE': 'movement',
    'NEAR': 'near',
    'PEAQ': 'peaq',
    'DOT': 'polkadot',
    'SEI': 'sei-network',
    'S': 'sonic',
    'STORY': 'story',
    'XION': 'xion',
    'BID': 'creatorbid',
    'NEWT': 'newton',
    'VIRTUAL': 'virtuals-protocol',
    'WARD': 'warden',
    'PROMPT': 'wayfinder',
    'ANIME': 'anime',
    'BOOP': 'boop',
    'PENGU': 'pengu',
    'CORN': 'corn',
    'GOATED': 'goat-network',
    'ARB': 'arbitrum',
    'KAT': 'katana-inu',
    'MNT': 'mantle',
    'MATIC': 'matic-network',
    'SOON': 'soon',
    'FF': 'falcon-finance',
    'FRAX': 'frax',
    'HUMA': 'huma-finance',
    'ORDER': 'orderly-network',
    'PYTH': 'pyth-network',
    'STRK': 'starknet',
    'ZEC': 'zcash',
    'H': 'humanity-protocol',
    'DYDX': 'dydx',
    'KAITO': 'kaito',
    'IQ': 'everipedia',
    'UXLINK': 'uxlink',
    'DEFI': 'defi-app',
    'NXPC': 'maplestory-universe',
    'SOPH': 'sophon',
    'INIT': 'initia',
    'SKATE': 'skate'
  };
  
  return tickerMap[ticker.toUpperCase()] || ticker.toLowerCase();
}

/**
 * Parse start date string and return Unix timestamp in seconds
 * Handles various date formats:
 * - "March 21, 2025" (specific date)
 * - "December 2024" (month and year)
 * - "Early 2025" (vague date - uses January 1st)
 * Returns Unix timestamp in seconds for CoinGecko API range endpoint
 */
export function parseStartDateToTimestamp(startDate: string): number {
  const now = Date.now();
  const normalized = startDate.toLowerCase().trim();
  
  let timestamp: number;
  
  // Handle "Early 2025" format - use January 1st of that year
  if (normalized.includes('early')) {
    const yearMatch = startDate.match(/\d{4}/);
    if (yearMatch) {
      const year = parseInt(yearMatch[0]);
      timestamp = Date.UTC(year, 0, 1) / 1000; // January 1st in Unix seconds
    } else {
      // Fallback to 1 year ago
      timestamp = Math.floor((now - 365 * 24 * 60 * 60 * 1000) / 1000);
    }
  }
  // Handle "December 2024" format (month and year only) - use first of the month
  else if (/^[a-z]+\s+\d{4}$/.test(normalized)) {
    try {
      // Try parsing "Month Year" format - add "1" to make it parseable
      const parsed = Date.parse(startDate + ' 1') / 1000;
      if (!isNaN(parsed)) {
        timestamp = parsed;
      } else {
        // Fallback: parse manually
        const parts = startDate.trim().split(' ');
        const monthName = parts[0];
        const year = parseInt(parts[1]);
        const monthMap: Record<string, number> = {
          'january': 0, 'february': 1, 'march': 2, 'april': 3,
          'may': 4, 'june': 5, 'july': 6, 'august': 7,
          'september': 8, 'october': 9, 'november': 10, 'december': 11
        };
        const month = monthMap[monthName.toLowerCase()] ?? 0;
        timestamp = Date.UTC(year, month, 1) / 1000;
      }
    } catch {
      // Fallback to 1 year ago
      timestamp = Math.floor((now - 365 * 24 * 60 * 60 * 1000) / 1000);
    }
  }
  // Handle "March 21, 2025" format (specific date)
  else {
    const parsed = Date.parse(startDate) / 1000;
    if (!isNaN(parsed)) {
      timestamp = parsed;
    } else {
      // Fallback to 1 year ago
      timestamp = Math.floor((now - 365 * 24 * 60 * 60 * 1000) / 1000);
    }
  }
  
  // If start date is in the future, use current date minus 1 year
  // This ensures we get available historical data
  const nowSeconds = Math.floor(now / 1000);
  if (timestamp > nowSeconds) {
    timestamp = Math.floor((now - 365 * 24 * 60 * 60 * 1000) / 1000);
  }
  
  return timestamp;
}

/**
 * Parse start date string and return number of days from that date to now
 * Handles various date formats:
 * - "March 21, 2025" (specific date)
 * - "December 2024" (month and year)
 * - "Early 2025" (vague date - uses January 1st)
 * Returns max 365 days for CoinGecko API compatibility
 * @deprecated Use parseStartDateToTimestamp instead for range endpoint
 */
export function getDaysFromStartDate(startDate: string): number {
  const timestamp = parseStartDateToTimestamp(startDate);
  const nowSeconds = Math.floor(Date.now() / 1000);
  const days = Math.ceil((nowSeconds - timestamp) / (24 * 60 * 60));
  
  if (days <= 0) {
    return 30; // Default to 30 days
  }
  
  // CoinGecko API supports: 1, 7, 14, 30, 90, 180, 365, max
  if (days <= 1) return 1;
  if (days <= 7) return 7;
  if (days <= 14) return 14;
  if (days <= 30) return 30;
  if (days <= 90) return 90;
  if (days <= 180) return 180;
  if (days <= 365) return 365;
  return 365;
}

